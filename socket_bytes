1：socket的传输解析:

A:byte(字节)的概念
一个socket管道传输信息就是传输数组byte[]的过程,
socket 原生的传输是二进制，一个字符就是一个byte，
8位=1字节,仅能代表(0000 0000 - 0111 1111)的字符,就产生了ascii码

B:ascii码的概念
ascii码到目前为止共定义了128个字符，空字符到删除
(0011 0000 - 0111 1010)是(0-小写z)的范围
128个符号是不够的，所以产生了扣展码，光是GB2312,使用两个字节代表一个汉子就有(0xFF+1)256 x (0xFF+1)256 = 65536个

C:所以，普通的byte，8位最大值是127,如果有汉字就是必须用两个byte表示一个汉字(0x00-0xFF)


---------------运算(正数的原码和反码和补码是一致的)(补码是反码加1)(求反码记得符号位不能动，逆原码记得不要动符号位)(加符号就是加1000，例如-3 = 1000 0011)----------------------
D:按位与(同位1才为1，1&1=1 0&1=0，0&0=0)
  {
  126 & -253 = 2
  运算过程 
  126 = 0x7E = 0000 0111 1110 
  253 = 0xFD = 0000 1111 1101，-253 = 1000 1111 1101（1000中的1是符号位）

  126的补码是原码0111 1110 
  253的反码是1111 0000 0010,补码(反码加1)是1111 0000 0011

  1111 0000 0011 & 0000 0111 1110 = 0000 0000 0010 = 2(符号位是正的，2是补码也是原码); 
  }
  {
    -126 & -253 = -254
    运算过程 
    -126 = 0x7E = 1000 0111 1110 
    -253 = 1000 1111 1101（1000中的1是符号位）
    -126的反码是1111 1000 0001 ,补码(反码加1)是1111 1000 0010
    -253的反码是1111 0000 0010,补码(反码加1)是1111 0000 0011
    1111 1000 0010 & 1111 0000 0011 = 1111 0000 0010（符号位是负，进行求原码） 
    1111 0000 0010的逆反码 1111 0000 0001,原码是 1000 1111 1110 = -254
  }
  
E:按位或
  {
  -40 |30 = -34
  运算过程 
  40 = 0x28 ,-40 = 1000 0010 1000
  30 = 0x1E , 30 = 0000 0001 1110
  30的补码 0000 0001 1110
  -40的反码：1111 1101 0111 ，补码是1111 1101 1000
  1111 1101 1000 | 0000 0001 1110 = 1111 1101 1110(结果符号位是负，进行求原码)
  1111 1101 1110的逆反码是1111 1101 1101,原码是 1000 0010 0010 = -34
  }

F：左移
3<<8 = 3*2^8 = 768
G：右移
18>>3 = 18/2^3 = 2

H:扣展（An代表任何值）
0x0F = 00001111
An & 0x0F = An的二进制的后四位,(An)&0x0F = An%(0x0F+1)

0x7F = 0111 1111
An & 0x7F = An的二进制的后七位,(An)&0x7F = An%(0x7F+1)

socket传输过程中如果有body长度的比特，例如[123,23]，一般用16位表示，也就是2个字节，一个字节在高位123，一个低位23，高低*256+低位值 = 长度
